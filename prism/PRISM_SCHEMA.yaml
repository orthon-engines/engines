# PRISM Canonical Schema v2.0.0
# ==============================
#
# BREAKING CHANGE: entity_id → unit_id (now OPTIONAL)
#
# THIS IS THE SINGLE SOURCE OF TRUTH.

version: "2.0.0"
name: "PRISM Observations Schema"
description: "Canonical schema for observations.parquet consumed by PRISM"

# =============================================================================
# COLUMNS
# =============================================================================

columns:
  unit_id:
    description: |
      Optional label for grouping signals.

      This is just a tag - a sticky note for humans.
      ZERO effect on compute. PRISM passes it through.
      Used for SQL filtering after compute.

      Can be:
      - A physical thing: "pump_1", "patient_42"
      - A category: "Consumer_Staples", "stocks"
      - An arbitrary grouping: "friday_data", "batch_001"
      - Literally anything: "bananas"
      - Empty: "" (totally fine)
      - Null: (also fine)

      Cannot be:
      - An index (that's what I is for)
      - Sequential numbers used for ordering

    type: "string"
    nullable: true
    default: ""
    required: false
    examples: ["pump_1", "Consumer_Staples", "friday_data", "bananas", ""]

  signal_id:
    description: |
      Identifies what is being measured.
      Each unique signal_id becomes a vector.
      REQUIRED - PRISM needs this.
    type: "string"
    nullable: false
    required: true
    examples: ["temp", "pressure", "return", "acc_x", "acc_y"]

  I:
    description: |
      Index. Orders values within each unit+signal combination.
      MUST be sequential: 0, 1, 2, 3, ...
      REQUIRED - PRISM needs this to build vectors.
    type: "uint32"
    nullable: false
    required: true
    constraints:
      - "Sequential integers starting at 0"
      - "Resets for each unit+signal combination"
      - "No gaps (0,1,2,3... not 0,10,20,30...)"
    examples: [0, 1, 2, 3, 4]

  value:
    description: |
      The measurement. The actual number.
      REQUIRED - this is the data.
    type: "float64"
    nullable: true  # NaN allowed for missing data
    required: true
    examples: [25.3, -0.0042, 101.325]

# =============================================================================
# REQUIREMENTS
# =============================================================================

required_columns: ["signal_id", "I", "value"]
optional_columns: ["unit_id"]

requirements:
  min_signals: 2
  reason: "Pair engines need at least 2 signals"

  min_observations: 50
  reason: "Windowed engines need sufficient data"

  I_must_be_sequential: true
  reason: "Vectors must have consistent ordering"

  unit_id_required: false
  reason: "It's just a label. Blank is fine."

# =============================================================================
# VALIDATION RULES
# =============================================================================

validation_rules:

  - id: "REQUIRED_COLUMNS"
    severity: "error"
    check: "Required columns present"
    columns: ["signal_id", "I", "value"]

  - id: "COLUMN_TYPES"
    severity: "error"
    check: "Columns have correct types"
    rules:
      unit_id: "string (if present)"
      signal_id: "string"
      I: "integer (uint32, uint64, int32, int64)"
      value: "float (float32, float64)"

  - id: "NO_NULLS_IN_KEYS"
    severity: "error"
    check: "No null values in signal_id or I"
    columns: ["signal_id", "I"]

  - id: "I_SEQUENTIAL"
    severity: "error"
    check: "I is sequential 0,1,2,3... per unit/signal"
    test: "max(I) - min(I) + 1 == count(I) for each unit/signal group"

  - id: "I_STARTS_ZERO"
    severity: "error"
    check: "I starts at 0 for each unit"
    test: "min(I) == 0 for each unit"

  - id: "MIN_SIGNALS"
    severity: "error"
    check: "At least 2 signals exist"
    test: "count(distinct signal_id) >= 2"
    message: "Pair engines require at least 2 signals"

  - id: "MIN_OBSERVATIONS"
    severity: "warning"
    check: "Each unit/signal has >= 50 observations"
    test: "count(*) >= 50 for each unit/signal group"
    message: "Some engines may produce NaN with insufficient data"

# =============================================================================
# EXAMPLES
# =============================================================================

example_valid:
  description: "Correctly formatted observations"
  data: |
    unit_id | signal_id | I | value
    --------|-----------|---|------
    pump_1  | temp      | 0 | 25.3
    pump_1  | temp      | 1 | 25.4
    pump_1  | pressure  | 0 | 101.2
    pump_1  | pressure  | 1 | 101.3
            | temp      | 0 | 30.1    ← blank unit_id is fine
            | pressure  | 0 | 99.8

example_invalid:
  - problem: "Sparse I values"
    fix: "Reindex I to be sequential 0,1,2,3..."

  - problem: "Only 1 signal"
    fix: "Include additional signals for pair engines"

  - problem: "I doesn't start at 0"
    fix: "Subtract min(I) per unit to start at 0"

# =============================================================================
# SUMMARY
# =============================================================================

summary: |
  PRISM expects observations.parquet with columns:

  REQUIRED:
  - signal_id (string): What signal? (temp, pressure, acc_x)
  - I (integer): Observation number 0,1,2,3... per unit/signal
  - value (float): The measurement

  OPTIONAL:
  - unit_id (string): A label for grouping. Blank is fine.

  Rules:
  - I must be sequential (0,1,2,3...) not sparse
  - Need at least 2 signals for pair calculations
  - No nulls in signal_id or I
  - unit_id can be anything or blank - it's just a tag
